---
title: Schema Management
description: Learn how to define, synchronize, and migrate database schemas.
navigation:
  icon: i-lucide-settings
---

Schemas define the structure of your data sourcesâ€”the properties (columns), their types, and configurations. Unbook provides tools to define schemas declaratively and sync them with remote data sources.

## Understand schemas

A schema is a `Schema.Definition` object that maps internal keys to field definitions:

```ts [schema-structure.ts]
import type { Schema } from '@unbook/core'

const taskSchema = {
  // key: internal name used in your code
  // label: display name in the UI
  // type: the property type
  name: { label: 'Task Name', type: 'title' },
  status: { label: 'Status', type: 'select', options: ['To Do', 'In Progress', 'Done'] },
  dueDate: { label: 'Due Date', type: 'date' },
} satisfies Schema.Definition
```

Key concepts:
- **Keys** (`name`, `status`, `dueDate`) are used in your code
- **Labels** (`'Task Name'`, `'Status'`) are displayed in the UI
- **Types** determine validation and rendering

## Define a schema

### Basic schema

```ts [basic-schema.ts]
import type { Schema } from '@unbook/core'

const projectSchema = {
  name: { label: 'Project Name', type: 'title' },
  description: { label: 'Description', type: 'rich_text' },
  startDate: { label: 'Start Date', type: 'date' },
  isActive: { label: 'Active', type: 'checkbox' },
  budget: { label: 'Budget', type: 'number', format: 'dollar' },
  website: { label: 'Website', type: 'url' },
  contactEmail: { label: 'Contact', type: 'email' },
} satisfies Schema.Definition
```

### Using shorthand helpers

Field shorthands simplify schema definition:

```ts [shorthand-schema.ts]
import { title, richText, date, checkbox, number, url, email } from '@unbook/core'

const projectSchema = {
  name: title('Project Name'),
  description: richText('Description'),
  startDate: date('Start Date'),
  isActive: checkbox('Active'),
  budget: number('Budget', 'dollar'),
  website: url('Website'),
  contactEmail: email('Contact'),
}
```

## Use field options

### Number formats

```ts [number-formats.ts]
const schema = {
  price: { label: 'Price', type: 'number', format: 'dollar' },
  percentage: { label: 'Completion', type: 'number', format: 'percent' },
  quantity: { label: 'Quantity', type: 'number', format: 'number' },
  rating: { label: 'Rating', type: 'number', format: 'number_with_commas' },
} satisfies Schema.Definition
```

Available formats: `number`, `number_with_commas`, `percent`, `dollar`, `canadian_dollar`, `euro`, `pound`, `yen`, `ruble`, `rupee`, `won`, `yuan`, and more.

### Select and multi-select options

```ts [select-options.ts]
const schema = {
  // Simple array of options
  priority: {
    label: 'Priority',
    type: 'select',
    options: ['Low', 'Medium', 'High', 'Critical'],
  },

  // Options with colors
  category: {
    label: 'Category',
    type: 'select',
    options: {
      feature: { label: 'Feature', color: 'blue' },
      bug: { label: 'Bug', color: 'red' },
      docs: { label: 'Documentation', color: 'green' },
    },
  },

  // Multi-select for multiple values
  tags: {
    label: 'Tags',
    type: 'multi_select',
    options: ['frontend', 'backend', 'api', 'database', 'ui'],
  },
} satisfies Schema.Definition
```

### Status with groups

```ts [status-groups.ts]
const schema = {
  status: {
    label: 'Status',
    type: 'status',
    groups: {
      notStarted: {
        label: 'Not Started',
        color: 'gray',
        options: ['Backlog', 'To Do'],
      },
      inProgress: {
        label: 'In Progress',
        color: 'blue',
        options: ['In Development', 'In Review'],
      },
      complete: {
        label: 'Complete',
        color: 'green',
        options: ['Done', 'Archived'],
      },
    },
  },
} satisfies Schema.Definition
```

### Relations and rollups

```ts [relations.ts]
const taskSchema = {
  name: { label: 'Task', type: 'title' },

  // Relation to another database
  project: {
    label: 'Project',
    type: 'relation',
    database_id: 'project-database-id',
    single_property: true, // One-way relation
  },

  // Rollup from related records
  projectBudget: {
    label: 'Project Budget',
    type: 'rollup',
    relation_property: 'Project',
    rollup_property: 'Budget',
    function: 'sum',
  },
} satisfies Schema.Definition
```

### Formulas

```ts [formulas.ts]
const schema = {
  quantity: { label: 'Quantity', type: 'number' },
  unitPrice: { label: 'Unit Price', type: 'number', format: 'dollar' },

  // Formula referencing other properties
  total: {
    label: 'Total',
    type: 'formula',
    // Use prop("key") with schema keys, not labels
    expression: 'prop("quantity") * prop("unitPrice")',
  },

  // Formula with date functions
  daysUntilDue: {
    label: 'Days Until Due',
    type: 'formula',
    expression: 'dateBetween(prop("dueDate"), now(), "days")',
  },
} satisfies Schema.Definition
```

### Complete example

```ts [complete-schema.ts]
import type { Schema } from '@unbook/core'

const invoiceSchema = {
  // Primary key
  invoiceNumber: { label: 'Invoice #', type: 'title' },

  // Text fields
  clientName: { label: 'Client', type: 'rich_text' },
  notes: { label: 'Notes', type: 'rich_text' },

  // Numbers
  amount: { label: 'Amount', type: 'number', format: 'dollar' },
  taxRate: { label: 'Tax Rate', type: 'number', format: 'percent' },

  // Dates
  issueDate: { label: 'Issue Date', type: 'date' },
  dueDate: { label: 'Due Date', type: 'date' },

  // Select
  status: {
    label: 'Status',
    type: 'select',
    options: ['Draft', 'Sent', 'Paid', 'Overdue', 'Cancelled'],
  },

  // Checkbox
  isPaid: { label: 'Paid', type: 'checkbox' },

  // Formula
  totalWithTax: {
    label: 'Total with Tax',
    type: 'formula',
    expression: 'prop("amount") * (1 + prop("taxRate"))',
  },

  // System fields (read-only)
  createdAt: { label: 'Created', type: 'created_time' },
  updatedAt: { label: 'Updated', type: 'last_edited_time' },
  createdBy: { label: 'Created By', type: 'created_by' },
} satisfies Schema.Definition
```

## Infer schema from existing data source

If you have an existing database, you can infer its schema:

```ts [infer-schema.ts]
const dataSource = await database.getPrimaryDataSource()

// Infer schema from remote properties
const inferredSchema = dataSource.inferSchema()

console.log(inferredSchema)
// {
//   taskName: { label: 'Task Name', type: 'title', id: 'title' },
//   status: { label: 'Status', type: 'select', id: 'abc123', options: [...] },
//   ...
// }
```

This is useful for:
- Exploring an unknown database structure
- Creating a starting point for your schema definition
- Debugging schema mismatches

## Detect schema differences

Compare local and remote schemas using `diffSchema()`:

```ts [diff-schema.ts]
import { diffSchema } from '@unbook/core'

const localSchema = {
  name: { label: 'Name', type: 'title' },
  status: { label: 'Status', type: 'select', options: ['To Do', 'Done'] },
  priority: { label: 'Priority', type: 'number' }, // New field
}

const remoteSchema = dataSource.inferSchema()

const changes = diffSchema(remoteSchema, localSchema)

for (const change of changes) {
  console.log(change.type, change.key, change.field?.label)
}
// Output:
// 'add' 'priority' 'Priority'
// 'update' 'status' 'Status' (options changed)
```

### Change types

| Type | Description |
|------|-------------|
| `add` | Field exists in local but not remote |
| `update` | Field exists in both but differs |
| `remove` | Field exists in remote but not local |

## Apply schema changes

Use `dataSource.ensureSchema()` to synchronize schemas:

```ts [ensure-schema.ts]
const dataSource = await database.getPrimaryDataSource()

// Sync schema with 'merge' strategy (default)
const synced = await dataSource.ensureSchema(mySchema, 'merge')

// Now use the typed data source
for await (const record of synced.find()) {
  console.log(record.name) // Typed!
}
```

### Conflict strategies

#### Strict mode

Throws an error if the remote has fields not defined in your local schema:

```ts [strict-mode.ts]
try {
  await dataSource.ensureSchema(mySchema, 'strict')
} catch (error) {
  console.error('Schema conflict:', error.message)
  // "Remote schema has unrecognized fields: legacyField, oldColumn"
}
```

Use strict mode when you need full control over the schema.

#### Merge mode (default)

Keeps remote fields that don't conflict, adds/updates your local fields:

```ts [merge-mode.ts]
// Remote has: name, status, legacyField
// Local has: name, status, priority

const merged = await dataSource.ensureSchema(mySchema, 'merge')
// Result: name, status, legacyField, priority
// - name/status updated to match local
// - legacyField kept from remote
// - priority added from local
```

Use merge mode for gradual migrations where you don't want to lose existing data.

#### Overwrite mode

Replaces the remote schema entirely, removing fields not in your local schema:

```ts [overwrite-mode.ts]
// Remote has: name, status, legacyField
// Local has: name, status, priority

const overwritten = await dataSource.ensureSchema(mySchema, 'overwrite')
// Result: name, status, priority
// - legacyField deleted!
```

::warning
Overwrite mode deletes remote fields not in your schema. Data in those fields will be lost.
::

## Handle schema conflicts

### Graceful error handling

```ts [handle-conflicts.ts]
import { SchemaConflictError } from '@unbook/core'

async function syncSchema(dataSource: DataSource, schema: Schema.Definition) {
  try {
    return await dataSource.ensureSchema(schema, 'strict')
  } catch (error) {
    if (error instanceof SchemaConflictError) {
      console.warn('Schema has extra fields:', error.extraFields)

      // Fall back to merge strategy
      return await dataSource.ensureSchema(schema, 'merge')
    }
    throw error
  }
}
```

### Preview changes before applying

```ts [preview-changes.ts]
import { diffSchema } from '@unbook/core'

const remoteSchema = dataSource.inferSchema()
const changes = diffSchema(remoteSchema, mySchema)

// Review changes
console.log('Changes to apply:')
for (const change of changes) {
  if (change.type === 'add') {
    console.log(`  + Add field: ${change.field.label}`)
  } else if (change.type === 'update') {
    console.log(`  ~ Update field: ${change.field.label}`)
  } else if (change.type === 'remove') {
    console.log(`  - Remove field: ${change.key}`)
  }
}

// Ask for confirmation before applying
if (await confirm('Apply these changes?')) {
  await dataSource.ensureSchema(mySchema, 'overwrite')
}
```

## Schema migration patterns

### Adding new fields

New fields are added automatically with `merge` or `overwrite`:

```ts [add-fields.ts]
// v1 schema
const v1 = {
  name: { label: 'Name', type: 'title' },
}

// v2 schema - added priority
const v2 = {
  name: { label: 'Name', type: 'title' },
  priority: { label: 'Priority', type: 'number' },
}

await dataSource.ensureSchema(v2, 'merge')
// priority field is added, existing data preserved
```

### Renaming fields

To rename a field, preserve its ID:

```ts [rename-fields.ts]
// Get the current schema with IDs
const current = dataSource.inferSchema()

// Create new schema with preserved ID
const updated = {
  // Use the same ID to rename instead of delete+create
  taskName: {
    label: 'Task Name', // New label
    type: 'title',
    id: current.name.id, // Preserve the ID!
  },
}

await dataSource.ensureSchema(updated, 'merge')
```

### Removing deprecated fields

Use `overwrite` to remove fields:

```ts [remove-fields.ts]
// Old schema
const old = {
  name: { label: 'Name', type: 'title' },
  legacyField: { label: 'Legacy', type: 'rich_text' },
}

// New schema without legacy field
const updated = {
  name: { label: 'Name', type: 'title' },
}

// Overwrite removes legacyField
await dataSource.ensureSchema(updated, 'overwrite')
```

### Multi-step migrations

For complex migrations, apply changes incrementally:

```ts [multi-step.ts]
async function migrateToV3(dataSource: DataSource) {
  // Step 1: Add new fields
  await dataSource.ensureSchema({
    ...v2Schema,
    newField: { label: 'New Field', type: 'rich_text' },
  }, 'merge')

  // Step 2: Migrate data
  for await (const page of dataSource.findPages()) {
    // Copy data from old field to new field
    await page.update({
      properties: {
        'New Field': page.object.properties['Old Field'],
      },
    })
  }

  // Step 3: Remove old fields
  await dataSource.ensureSchema(v3Schema, 'overwrite')
}
```
