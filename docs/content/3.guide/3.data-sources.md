---
title: Data Sources
description: Learn how to query, filter, sort, and manage data in data sources.
navigation:
  icon: i-lucide-table
---

Data sources are the actual tables within a database. They contain rows (as pages) with properties defined by a schema. This guide covers querying, filtering, and CRUD operations.

## Understand data sources

A DataSource represents a table with:
- A **schema** defining the columns (properties) and their types
- **Rows** stored as pages, each with property values
- **Query capabilities** for filtering, sorting, and pagination

```ts [data-source-basics.ts]
// Get a data source from a database
const database = await workspace.getDatabase('database-id')
const dataSource = await database.getPrimaryDataSource()

// Access data source properties
console.log('ID:', dataSource.id)
console.log('Title:', dataSource.title)
console.log('Properties:', dataSource.properties)
```

## Attach a schema

For type-safe operations, attach a schema definition to the data source:

```ts [attach-schema.ts]
import type { Schema } from '@unbook/core'

// Define your schema
const taskSchema = {
  name: { label: 'Name', type: 'title' },
  status: { label: 'Status', type: 'select', options: ['To Do', 'In Progress', 'Done'] },
  dueDate: { label: 'Due Date', type: 'date' },
  priority: { label: 'Priority', type: 'number' },
} satisfies Schema.Definition

// Attach the schema
const typedDataSource = dataSource.withSchema(taskSchema)

// Now queries return typed records
for await (const task of typedDataSource.find()) {
  // task is typed as { name: string, status: string, dueDate: Date | null, priority: number }
  console.log(task.name, task.status)
}
```

## Query pages (untyped)

Use `findPages()` when you need raw page objects without schema transformation:

```ts [find-pages.ts]
// Iterate over all rows as Page objects
for await (const page of dataSource.findPages()) {
  console.log(page.id, page.title)
  console.log(page.object.properties) // Raw property values
}

// Get a single page
const firstPage = await dataSource.findOnePage()
if (firstPage) {
  console.log('Found:', firstPage.title)
}
```

## Query records (typed)

Use `find()` with an attached schema for type-safe, hydrated records:

```ts [find-records.ts]
const dataSource = (await database.getPrimaryDataSource())
  .withSchema(taskSchema)

// Query all records with automatic hydration
for await (const task of dataSource.find()) {
  console.log(task.name)      // string
  console.log(task.status)    // 'To Do' | 'In Progress' | 'Done'
  console.log(task.dueDate)   // Date | null
  console.log(task.priority)  // number
}

// Get a single record
const task = await dataSource.findOne()
if (task) {
  console.log('First task:', task.name)
}
```

## Filter results

Pass filter options to narrow down results:

```ts [filter-basics.ts]
// Filter by a single property
for await (const task of dataSource.find({
  filter: {
    property: 'Status',
    select: { equals: 'In Progress' },
  },
})) {
  console.log(task.name)
}
```

### Filter operators by property type

Different property types support different operators:

```ts [filter-operators.ts]
// Text filters
const textFilter = {
  property: 'Name',
  rich_text: {
    contains: 'urgent',
    // Other options: equals, does_not_equal, starts_with, ends_with,
    // does_not_contain, is_empty, is_not_empty
  },
}

// Number filters
const numberFilter = {
  property: 'Priority',
  number: {
    greater_than: 5,
    // Other options: equals, does_not_equal, greater_than_or_equal_to,
    // less_than, less_than_or_equal_to, is_empty, is_not_empty
  },
}

// Date filters
const dateFilter = {
  property: 'Due Date',
  date: {
    before: '2024-12-31',
    // Other options: after, equals, on_or_before, on_or_after,
    // is_empty, is_not_empty, past_week, past_month, past_year,
    // next_week, next_month, next_year
  },
}

// Select filters
const selectFilter = {
  property: 'Status',
  select: {
    equals: 'Done',
    // Other options: does_not_equal, is_empty, is_not_empty
  },
}

// Checkbox filters
const checkboxFilter = {
  property: 'Completed',
  checkbox: {
    equals: true,
    // Other options: does_not_equal
  },
}
```

### Compound filters

Combine multiple conditions with `and` or `or`:

```ts [compound-filters.ts]
// AND: All conditions must match
for await (const task of dataSource.find({
  filter: {
    and: [
      { property: 'Status', select: { equals: 'In Progress' } },
      { property: 'Priority', number: { greater_than: 3 } },
    ],
  },
})) {
  console.log(task.name)
}

// OR: Any condition can match
for await (const task of dataSource.find({
  filter: {
    or: [
      { property: 'Status', select: { equals: 'Urgent' } },
      { property: 'Due Date', date: { before: new Date().toISOString() } },
    ],
  },
})) {
  console.log(task.name)
}

// Nested compound filters
for await (const task of dataSource.find({
  filter: {
    and: [
      { property: 'Status', select: { does_not_equal: 'Done' } },
      {
        or: [
          { property: 'Priority', number: { greater_than: 8 } },
          { property: 'Due Date', date: { past_week: {} } },
        ],
      },
    ],
  },
})) {
  console.log(task.name)
}
```

## Sort results

Order results by one or more properties:

```ts [sort-results.ts]
// Sort by a single property
for await (const task of dataSource.find({
  sorts: [
    { property: 'Due Date', direction: 'ascending' },
  ],
})) {
  console.log(task.name, task.dueDate)
}

// Sort by multiple properties
for await (const task of dataSource.find({
  sorts: [
    { property: 'Priority', direction: 'descending' },
    { property: 'Due Date', direction: 'ascending' },
  ],
})) {
  console.log(task.priority, task.name)
}

// Sort by timestamp
for await (const task of dataSource.find({
  sorts: [
    { timestamp: 'last_edited_time', direction: 'descending' },
  ],
})) {
  console.log(task.name, 'edited recently')
}
```

## Paginate large datasets

The async generator handles pagination automatically. Control page size for performance:

```ts [pagination.ts]
// Default pagination (handled automatically)
let count = 0
for await (const task of dataSource.find()) {
  count++
}
console.log('Total records:', count)

// Control page size for performance tuning
for await (const task of dataSource.find({ page_size: 100 })) {
  // Fetches 100 records at a time internally
  console.log(task.name)
}

// Limit results by breaking early
let fetched = 0
for await (const task of dataSource.find()) {
  console.log(task.name)
  fetched++
  if (fetched >= 10) break // Stop after 10 records
}
```

## Insert records

Use `insert()` to create new rows with typed data:

```ts [insert-record.ts]
const dataSource = (await database.getPrimaryDataSource())
  .withSchema(taskSchema)

// Insert a new record
const page = await dataSource.insert({
  name: 'Review pull request',
  status: 'To Do',
  dueDate: new Date('2024-03-15'),
  priority: 7,
})

console.log('Created:', page.id)
```

The data is automatically dehydrated from JavaScript types to the API format.

## Upsert records

Use `upsert()` to insert or update based on unique keys:

```ts [upsert-record.ts]
const dataSource = (await database.getPrimaryDataSource())
  .withSchema(taskSchema)

// Upsert by name - creates if not exists, updates if found
const page = await dataSource.upsert(['name'], {
  name: 'Daily standup',
  status: 'In Progress',
  dueDate: new Date('2024-03-10'),
  priority: 5,
})

console.log('Upserted:', page.id)
```

### Upsert with multiple unique keys

```ts [upsert-composite.ts]
// Use multiple properties as a composite unique key
const page = await dataSource.upsert(['name', 'dueDate'], {
  name: 'Weekly review',
  dueDate: new Date('2024-03-15'),
  status: 'To Do',
  priority: 3,
})
```

## Update data source settings

Modify the data source metadata:

```ts [update-data-source.ts]
const updated = await dataSource.update({
  title: 'Renamed Table',
  icon: 'ðŸ“‹',
})

console.log('Updated title:', updated.title)
```

## Sync schema

Ensure the remote schema matches your local definition:

```ts [sync-schema.ts]
const updated = await dataSource.ensureSchema(taskSchema, 'merge')

// The returned data source has the schema attached
for await (const task of updated.find()) {
  console.log(task.name) // Typed!
}
```

See the [Schema Management](/guide/schema-management) guide for details on conflict strategies and migrations.
