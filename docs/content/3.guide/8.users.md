---
title: Users
description: Learn how to retrieve user information and track content authorship.
navigation:
  icon: i-lucide-users
---

Users represent the people who create and edit content in your workspace. You can retrieve user details and track who created or last modified any entity.

## Retrieve a user

Use `workspace.getUser()` to fetch a user by their ID:

```ts [get-user.ts]
import { createNotionAdapter } from '@unbook/notion'
import { Workspace } from '@unbook/core'

const adapter = createNotionAdapter({ auth: process.env.NOTION_TOKEN })
const workspace = new Workspace(adapter)

const user = await workspace.getUser('user-id-here')

console.log('ID:', user.id)
console.log('Name:', user.name)
console.log('Avatar:', user.avatarUrl)
console.log('Email:', user.email) // May be undefined based on permissions
```

### User properties

| Property | Type | Description |
|----------|------|-------------|
| `id` | `string` | Unique identifier |
| `name` | `string` | Display name |
| `avatarUrl` | `string \| null` | Profile picture URL |
| `email` | `string \| undefined` | Email (if accessible) |
| `type` | `'person' \| 'bot'` | Whether user is human or integration |

## Get the current user

Use `workspace.getCurrentUser()` to get the authenticated user or bot:

```ts [get-current-user.ts]
const currentUser = await workspace.getCurrentUser()

console.log('Authenticated as:', currentUser.name)

if (currentUser.type === 'bot') {
  console.log('Running as integration bot')
} else {
  console.log('Running as user:', currentUser.email)
}
```

This is useful for:
- Displaying the current authentication context
- Logging which account is making API calls
- Conditional logic based on user type

## Access users from entities

Every entity (Page, Block, Database, DataSource) tracks its creator and last editor.

### Get page creator and editor

```ts [page-users.ts]
const page = await workspace.getPage('page-id')

// Get who created the page
const creator = await page.getCreator()
console.log('Created by:', creator.name)

// Get who last edited the page
const lastEditor = await page.getLastEditor()
console.log('Last edited by:', lastEditor.name)

// Access timestamps too
console.log('Created at:', page.createdAt)
console.log('Last edited at:', page.lastEditedAt)
```

### Get block creator and editor

```ts [block-users.ts]
for await (const block of page.getChildren()) {
  const creator = await block.getCreator()
  const editor = await block.getLastEditor()

  console.log(`Block ${block.type}:`)
  console.log(`  Created by ${creator.name} at ${block.createdAt}`)
  console.log(`  Last edited by ${editor.name} at ${block.lastEditedAt}`)
}
```

### Get database creator and editor

```ts [database-users.ts]
const database = await workspace.getDatabase('database-id')

const creator = await database.getCreator()
console.log('Database created by:', creator.name)

const editor = await database.getLastEditor()
console.log('Database last edited by:', editor.name)
```

### Get data source creator and editor

```ts [data-source-users.ts]
const dataSource = await database.getPrimaryDataSource()

const creator = await dataSource.getCreator()
console.log('Data source created by:', creator.name)

const editor = await dataSource.getLastEditor()
console.log('Data source last edited by:', editor.name)
```

## Build an audit trail

Track changes across your workspace:

```ts [audit-trail.ts]
interface AuditEntry {
  entityType: string
  entityId: string
  title: string
  createdBy: string
  createdAt: Date
  lastEditedBy: string
  lastEditedAt: Date
}

async function auditPage(page: Page): Promise<AuditEntry> {
  const creator = await page.getCreator()
  const editor = await page.getLastEditor()

  return {
    entityType: 'page',
    entityId: page.id,
    title: page.title,
    createdBy: creator.name,
    createdAt: page.createdAt,
    lastEditedBy: editor.name,
    lastEditedAt: page.lastEditedAt,
  }
}

// Audit all pages in a data source
const auditLog: AuditEntry[] = []

for await (const page of dataSource.findPages()) {
  auditLog.push(await auditPage(page))
}

// Sort by last edited
auditLog.sort((a, b) => b.lastEditedAt.getTime() - a.lastEditedAt.getTime())

console.log('Recent changes:')
for (const entry of auditLog.slice(0, 10)) {
  console.log(`${entry.title} - edited by ${entry.lastEditedBy} at ${entry.lastEditedAt}`)
}
```

## Track block-level changes

For detailed content auditing, traverse blocks:

```ts [block-audit.ts]
interface BlockChange {
  blockId: string
  blockType: string
  editedBy: string
  editedAt: Date
}

async function getRecentBlockChanges(page: Page): Promise<BlockChange[]> {
  const changes: BlockChange[] = []

  async function collectBlocks(blocks: AsyncIterable<Block>) {
    for await (const block of blocks) {
      const editor = await block.getLastEditor()

      changes.push({
        blockId: block.id,
        blockType: block.type,
        editedBy: editor.name,
        editedAt: block.lastEditedAt,
      })

      // Recurse into children
      if (block.object.has_children) {
        await collectBlocks(block.getChildren())
      }
    }
  }

  await collectBlocks(page.getChildren())

  // Sort by most recent
  return changes.sort((a, b) => b.editedAt.getTime() - a.editedAt.getTime())
}

const blockChanges = await getRecentBlockChanges(page)

console.log('Block changes:')
for (const change of blockChanges.slice(0, 5)) {
  console.log(`${change.blockType} edited by ${change.editedBy}`)
}
```

## User types

### Person users

Regular workspace members:

```ts [person-user.ts]
const user = await workspace.getUser('user-id')

if (user.type === 'person') {
  console.log('Human user:', user.name)
  console.log('Email:', user.email)
}
```

### Bot users

Integration accounts:

```ts [bot-user.ts]
const current = await workspace.getCurrentUser()

if (current.type === 'bot') {
  console.log('Integration:', current.name)
  // Bots don't have email addresses
}
```

## Caching user data

User lookups can be expensive. Cache results for efficiency:

```ts [cache-users.ts]
class UserCache {
  private cache = new Map<string, User>()

  constructor(private workspace: Workspace) {}

  async get(id: string): Promise<User> {
    let user = this.cache.get(id)

    if (!user) {
      user = await this.workspace.getUser(id)
      this.cache.set(id, user)
    }

    return user
  }
}

const userCache = new UserCache(workspace)

// First call fetches from API
const user1 = await userCache.get('user-id')

// Second call uses cache
const user2 = await userCache.get('user-id')
```

## People property in schemas

The `people` property type stores references to users:

```ts [people-property.ts]
const schema = {
  name: { label: 'Task', type: 'title' },
  assignees: { label: 'Assignees', type: 'people' },
}

// Hydrated records contain user IDs
for await (const task of dataSource.find()) {
  console.log('Task:', task.name)
  console.log('Assigned to:', task.assignees) // ['user-id-1', 'user-id-2']

  // Resolve to full user objects
  for (const userId of task.assignees) {
    const user = await workspace.getUser(userId)
    console.log('  -', user.name)
  }
}
```
