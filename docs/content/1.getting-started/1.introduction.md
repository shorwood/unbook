---
title: Introduction
description: Learn what Unbook is and how it provides a unified API for document manipulation across knowledge management platforms.
navigation:
  icon: i-lucide-info
---

## What is Unbook?

Unbook *(short for "Unified Notebook")* is a TypeScript framework that provides a **unified, type-safe interface** for document manipulation across knowledge management platforms. Currently supporting ***Notion***, with more platforms planned.

Instead of learning the intricacies of each platform's API, you write your code once using Unbook's clean abstractions. Entity classes like `Page`, `Database`, and `Block` provide methods for common operations, while the adapter pattern prepares you for future multi-platform support.

::note{icon="i-lucide-github" to="https://github.com/shorwood/unbook"}
Unbook is open source. Star us on GitHub and contribute!
::

## tldr;

::tabs{.w-full}
:::tabs-item{icon="i-lucide-database" label="Database"}
::::steps{level="4"}
#### Import dependencies
```ts
import { Workspace } from '@unbook/core'
import { Notion } from '@unbook/notion'
```

#### Instantiate the Notion adapter and workspace
```ts
const adapter = new Notion({ token: process.env.NOTION_TOKEN })
const workspace = new Workspace(adapter)
```

#### Get a database and its primary data source
```ts
const database = await workspace.getDatabase('tasks-database-id')
const dataSource = await database.getPrimaryDataSource()
```

#### Query entries with a filter
```ts
const results = dataSource.query({
  filter: {
    property: 'Status',
    select: { equals: 'In Progress' },
  },
})
```

#### Iterate over results
```ts
for await (const entry of results) {
  console.log(`${entry.name} is ${entry.status}`) // "Task 1 is In Progress"
}
```
::::
:::

:::tabs-item{icon="i-lucide-search" label="Search"}
::::steps{level="4"}
#### Import dependencies
```ts
import { Workspace } from '@unbook/core'
import { Notion } from '@unbook/notion'
```

#### Instantiate the Notion adapter and workspace
```ts
const adapter = new Notion({ token: process.env.NOTION_TOKEN })
const workspace = new Workspace(adapter)
```
#### Search for pages with "project" in the title or content
```ts
const pages = workspace.search('project', { filter: 'page' })
```

#### Iterate over search results
```ts
for await (const page of pages) {
  console.log(page.title, page.url)
}
```
::::
:::

:::tabs-item{icon="i-lucide-file-text" label="To Markdown"}
::::steps{level="4"}
#### Import dependencies
```ts
import { Workspace } from '@unbook/core'
import { Notion } from '@unbook/notion'
```

#### Instantiate the Notion adapter and workspace
```ts
const adapter = new Notion({ token: process.env.NOTION_TOKEN })
const workspace = new Workspace(adapter)
```

#### Get a page and render its blocks to plain text
```ts
const page = await workspace.getPage('page-id-here')
const markdown = await page.render()
console.log(markdown)
```
::::
:::

:::tabs-item{icon="i-lucide-user" label="Users"}
::::steps{level="4"}
#### Import dependencies
```ts
import { Workspace } from '@unbook/core'
import { Notion } from '@unbook/notion'
```

#### Instantiate the Notion adapter and workspace
```ts
const adapter = new Notion({ token: process.env.NOTION_TOKEN })
const workspace = new Workspace(adapter)
```

#### Get current and specific users
```ts
const currentUser = await workspace.getCurrentUser()
const userById = await workspace.getUser('user-id-here')
```
::::
:::
::


## Why is Unbook useful?

The Notion API is powerful but can be complex and inconsistent. Unbook simplifies this by providing:

::accordion
  :::accordion-item{icon="i-lucide-shield-check" label="Type-safe entities"}
  Work with rich TypeScript types instead of raw JSON. Every entity—pages, databases, blocks, and users—is fully typed, giving you autocompletion and compile-time checks. No more guessing property names or manually parsing nested structures.
  :::

  :::accordion-item{icon="i-lucide-file-code" label="Declarative schemas"}
  Define data models that map directly to Notion databases. Schemas let you describe your database structure once, then use it throughout your codebase with full type inference. Changes to your schema propagate automatically to all queries and mutations.
  :::

  :::accordion-item{icon="i-lucide-database" label="ORM-like(ish) operations"}
  Intuitive methods for creating, querying, and updating content. Instead of constructing complex API payloads, use familiar patterns like `.query()`, `.create()`, and `.update()`. Async iterators handle pagination automatically, so you can focus on your logic rather than API mechanics.
  :::

  :::accordion-item{icon="i-lucide-layers" label="Backend-agnostic design"}
  Write code that can work with multiple platforms in the future. The adapter pattern abstracts platform-specific details, meaning your application logic stays the same even when you add support for Obsidian, Confluence, or other knowledge management tools.
  :::
::